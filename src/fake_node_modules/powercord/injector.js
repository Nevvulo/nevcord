const { randomBytes } = require('crypto');

const injector = {
  injections: [],

  inject: (injectionId, mod, funcName, patch) => {
    if (!mod) {
      return injector._error(`Tried to patch undefined (Injection ID "${injectionId}")`);
    }

    if (injector.injections.find(i => i.id === injectionId)) {
      return injector._error(`Injection ID "${injectionId}" is already used!`);
    }

    if (!mod.__powercordInjectionId || !mod.__powercordInjectionId[funcName]) {
      // 1st injection
      const id = randomBytes(16).toString('hex');
      mod.__powercordInjectionId = Object.assign((mod.__powercordInjectionId || {}), { [funcName]: id });
      mod[funcName] = (_oldMethod => function (...args) { // eslint-disable-line func-names
        const returned = _oldMethod ? _oldMethod.call(this, ...args) : void 0;
        return injector._runInjections(id, args, returned, this);
      })(mod[funcName]);

      injector.injections[id] = [];
    }

    injector.injections.push({
      module: mod.__powercordInjectionId[funcName],
      id: injectionId,
      method: patch
    });
  },

  uninject: (injectionId) => {
    injector.injections = injector.injections.filter(i => i.id !== injectionId);
  },

  _runInjections: (modId, originArgs, originReturn, _this) => {
    let finalReturn = originReturn;
    const injections = injector.injections.filter(i => i.module === modId);
    injections.forEach(i => {
      try {
        finalReturn = i.method.call(_this, originArgs, finalReturn);
      } catch (e) {
        injector._error(`Failed to run injection "${i.id}"`, e);
      }
    });
    return finalReturn;
  },

  _error: (...args) => {
    console.error('%c[Powercord:Injector]', 'color: #257dd4', ...args);
  }
};

module.exports = injector;
